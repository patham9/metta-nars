;; stdlib extension
(= (ListConcat $L Nil) $L)
(= (ListConcat $C (Cons $LH $LT)) (ListConcat (Cons $LH $C) $LT))
(= (Included $element Nil) False)
(= (Included $element (Cons $head $tail)) (or (== $element $head) (Included $element $tail)))
(= (max $1 $2) (if (> $1 $2) $1 $2))
(= (min $1 $2) (if (< $1 $2) $1 $2))
(= (abs $x) (if (< $x 0) (- 0 $x) $x))
(: sequential (-> Expression %Undefined%))
(= (sequential $1) (superpose $1))
!(bind! &tempcount (new-state 0))
(= (TupleCount $x)
   (superpose ((case (change-state! &tempcount 0) ())
               (case (let $y (superpose $x)
                             (superpose ((change-state! &tempcount (+ 1 (get-state &tempcount)))))) ())
               (get-state &tempcount))))

(= (TupleCount2 ()) 0)
(= (TupleCount2 (1)) 1)
(= (BuildTupleCounts $TOld $C $N) 
   (let $T (collapse (superpose (1 (superpose $TOld))))
        (superpose ((add-atom &self (= (TupleCount2 $T) (+ $C 2)))
                    (if (< $C $N) (BuildTupleCounts $T (+ $C 1) $N) nop)))))
(= (CountElement $x) 1)
;;Build for count up to 100 (takes a few sec but it is worth it if space or generally collapse counts are often needed)
!(BuildTupleCounts (1) 0 100)
